/**
 * @file kmedoids_pywrapper.cpp
 * @date 2020-06-10
 *
 * Creates the Python bindings for the C++ code that
 * allows it to be called in Python.
 *
 */

#include "kmedoids_algorithm.hpp"
#include "log_helper.hpp"

#include <carma>
#include <armadillo>
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>

#define STRINGIFY(x) #x
#define MACRO_STRINGIFY(x) STRINGIFY(x)


namespace py = pybind11;

/**
 * @brief Never meant to be called; a debugging function. Sums to IDs of all available threads.
 * 
 * @return int: the n-th triangular number, where n is the number of threads
 */
int sum_thread_ids() {
  int sum=0;
  #pragma omp parallel shared(sum)
  {
    sleep(3);
    #pragma omp critical
    sum += omp_get_thread_num();
    std::cout << "Thread:" << omp_get_thread_num() << "\n";
  }
  return sum;
}

/**
 *  \brief Python wrapper for KMedoids class.
 *
 *  KMedoidsWrapper class. Is the Python wrapper generated by Pybind that allows for calling
 *  the C++ code in Python.
 */
class KMedoidsWrapper : public km::KMedoids {
public:
  using km::KMedoids::KMedoids;

  /**
   * \brief Python binding for fitting a KMedoids object to the
   *
   * This is the primary function of the KMedoids module: this finds the build and swap
   * medoids for the desired data
   *
   * @param inputData Input data to find the medoids of
   * @param loss The loss function used during medoid computation
   * @param k The number of medoids to compute
   * @param logFilename The name of the outputted log file
   */
  void fitPython(const py::array_t<double>& inputData, const std::string& loss, const std::string& logFilename,  py::kwargs kw) {
    // throw an error if the number of medoids is not specified in either 
    // the KMedoids object or the fitPython function
    try {
      if (KMedoids::getNMedoids() == 0) { // Check for 0 as NULL
        if (kw.size() == 0) {
          throw py::value_error("Must specify number of medoids via n_medoids in KMedoids or k in fit function.");
        }
      }
    } catch (py::value_error &e) {
      // Throw it again (pybind11 will raise ValueError)
      throw;
    }
    // if k is specified here, we set the number of medoids as k and override previous value 
    if ((kw.size() != 0) && (kw.contains("k"))) {
      KMedoids::setNMedoids(py::cast<int>(kw["k"]));
    }
    
    KMedoids::setLogFilename(logFilename);
    KMedoids::fit(carma::arr_to_mat<double>(inputData), loss , py::cast<std::string>(kw["mod_path"]), py::cast<std::string>(kw["dist_mat"]));
  }

  /**
   *  \brief Returns the final medoids
   *
   *  Returns as a numpy array the final medoids at the end of the SWAP step
   *  after KMedoids::fit has been called.
   */
  py::array_t<double> getMedoidsFinalPython() {
    return carma::row_to_arr<double>(KMedoids::getMedoidsFinal()).squeeze();
  }

  /**
   *  \brief Returns the build medoids
   *
   *  Returns as a numpy array the build medoids at the end of the BUILD step
   *  after KMedoids::fit has been called.
   */
  py::array_t<double> getMedoidsBuildPython() {
    return carma::row_to_arr<double>(KMedoids::getMedoidsBuild()).squeeze();
  }

  /**
   *  \brief Returns the medoid assignments for each datapoint
   *
   *  Returns as a numpy array the medoid each input datapoint is assigned to
   *  after KMedoids::fit is called and the final medoids have been identified
   */
  py::array_t<double> getLabelsPython() {
    return carma::row_to_arr<double>(KMedoids::getLabels()).squeeze();
  }

  /**
   *  \brief Returns the number of swap steps
   *
   *  Returns the number of SWAP steps completed during the last call to
   *  KMedoids::fit
   */
  int getStepsPython() {
    return KMedoids::getSteps();
  }
};

PYBIND11_MODULE(BanditPAM, m) {
  m.doc() = "BanditPAM Python library, implemented in C++";
  m.def("get_max_threads", &omp_get_max_threads, "Returns max number of threads");
  m.def("set_num_threads", &omp_set_num_threads, "Set the maximum number of threads");
  m.def("sum_thread_ids", &sum_thread_ids, "Adds the ids of threads; used only for debugging");
  py::class_<KMedoidsWrapper>(m, "KMedoids")
      .def(py::init<int, std::string, int, int, int, int, std::string, std::string, std::string>(),
        py::arg("n_medoids") = NULL,
        py::arg("algorithm") = "BanditPAM",
        py::arg("verbosity") = 0,
        py::arg("maxIter") = 1000,
        py::arg("buildConfidence") = 1000,
        py::arg("swapConfidence") = 10000,
        py::arg("logFilename") = "KMedoidsLogfile",
        py::arg("modPath") = "",
        py::arg("dist_mat") = ""
      )
      .def_property("n_medoids", &KMedoidsWrapper::getNMedoids, &KMedoidsWrapper::setNMedoids)
      .def_property("algorithm", &KMedoidsWrapper::getAlgorithm, &KMedoidsWrapper::setAlgorithm)
      .def_property("verbosity", &KMedoidsWrapper::getVerbosity, &KMedoidsWrapper::setVerbosity)
      .def_property("maxIter", &KMedoidsWrapper::getMaxIter, &KMedoidsWrapper::setMaxIter)
      .def_property("buildConfidence", &KMedoidsWrapper::getbuildConfidence, &KMedoidsWrapper::setbuildConfidence)
      .def_property("swapConfidence", &KMedoidsWrapper::getswapConfidence, &KMedoidsWrapper::setswapConfidence)
      .def_property("logFilename", &KMedoidsWrapper::getLogfileName, &KMedoidsWrapper::setLogFilename)
      .def_property("modPath", &KMedoidsWrapper::getModPath, &KMedoidsWrapper::setModPath)
      .def_property("dist_mat", &KMedoidsWrapper::getDistMat, &KMedoidsWrapper::setDistMat)
      .def_property_readonly("medoids", &KMedoidsWrapper::getMedoidsFinalPython)
      .def_property_readonly("build_medoids", &KMedoidsWrapper::getMedoidsBuildPython)
      .def_property_readonly("labels", &KMedoidsWrapper::getLabelsPython)
      .def_property_readonly("steps", &KMedoidsWrapper::getStepsPython)
      .def("fit", &KMedoidsWrapper::fitPython);
#ifdef VERSION_INFO
  m.attr("__version__") = MACRO_STRINGIFY(VERSION_INFO);
#else
  m.attr("__version__") = "dev";
#endif
}
